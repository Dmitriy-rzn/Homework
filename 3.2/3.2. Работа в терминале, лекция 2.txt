1)Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
 встроенная команда bash, меняет текущую папку только для оболочки, в которой выполняется.
2)Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
аналогом можно считать grep -e <some_string> <some_file> но он не считает количество вхождений, а -с считает только строки
3)Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
 1 root      20   0  101988  11492   8448 S   0.0   1.1   0:00.82 systemd
4)Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
ls 2> /dev/pts/1
5)Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
<1.txt >2.txt cat
6)Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
используя перенаправление вывода в файл к примеру echo test > / dev / tty1 данные не наблюдались
7)Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
создали перенаправление ввода в файл, в поддиректории с символьными ссылками на файлы, открытые нашим процессом
8)Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
rm file 3>&1 1>&2 2>&3 | sed 's/file/FILE!!!/' 
9)Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?
мы получили информацию о переменных окружения нашего процесса, командой export 
10)Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.
/proc/$pid/cmdline — Этот файл только для чтения содержит полную командную строку для процесса, если только процесс не является зомби.
В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки отображаются в этом файле в виде набора строк, разделенных нулевыми байтами
('\0'), с последующим нулевым байтом после последней строки.
/proc/$pid/exe - В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к исполняемому файлу.
команда. Эта символическая ссылка может быть разыменована нормально; попытка открыть ее откроет exe-файл‐
симпатичный. Вы даже можете ввести /proc/[pid]/exe, чтобы запустить другую копию того же исполняемого файла, который выполняется
выполняется процессом [pid]. Если путь был разорван, то символическая ссылка будет содержать строку
"(удалено)" добавляется к исходному пути. В многопоточном процессе содержимое этого символа‐
bolic link недоступны, если основной поток уже завершен (как правило, путем вызова
pthread_exit(3)).
11) Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr 
sse sse2 syscall nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq monitor 
ssse3 cx16 sse4_1 sse4_2 x2apic popcnt aes xsave avx hypervisor lahf_lm pti md_clear flush_l1d
12)При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
SSH не устанавливает TTY по умолчанию, когда явная команда передается в списке аргументов, добавляем -tt для исправления.
13)Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
открыл 2 screen в одном запустил top в другом сделал reptyr PID top 
14)sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
Команда tee в Linux нужна для записи вывода любой команды в один или несколько файлов.
не работает потому что sudo выполняет указанную программу с правами рута.
А перенаправление вывода в файл ">" выполняет не echo, а текущая оболочка права которой не изменились.
