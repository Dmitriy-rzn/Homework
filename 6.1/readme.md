# 6.1. Типы и структура СУБД

1. 

* Электронные чеки в json виде  
MongoDB хорошо работает с json
* Склады и автомобильные дороги для логистической компании  
Реляционная СУБД должна хорошо подойти, MySQL например. 
* Генеалогические деревья  
напрашивается иерархическая СУБД, но они устарели и имееют следующие недостатки неэффективность, медленный доступ к сегментам данных нижних уровней иерархии, четкая ориентация на определенные типы запросов, поэтому проще использовать MySQL
* Кэш идентификаторов клиентов с ограниченным временем жизни для движка аутенфикации  
Вариантами будут Memcached, Redis или Riak все примеры key-value СУБД
* Отношения клиент-покупка для интернет-магазина  
По идее все тоже самое что и для предудущего варианта key-value СУБД


2. 

* Данные записываются на все узлы с задержкой до часа (асинхронная запись)  
CAP: AP  
PACELC:P+C E+C  
* При сетевых сбоях, система может разделиться на 2 раздельных кластера  
CAP: AP  
PACELC: P+A E+L  
* Система может не прислать корректный ответ или сбросить соединение  
CAP: CP  
PACELC: P+C E+C  

3. 
Думаю могут, хотя по сути используются для разных подходов в работе с данными, но при этом в больших распределенных системах могут использоватся в зависимости от требований согласованности данных.

4. Похоже на Redis, из минусов можно выделить 

* Весь набор данных всегда находится в оперативной памяти, соответсвенно ограничены размером RAM
* Кластерные решения для Redis должны быть реализованы самостоятельно и требуют значительных усилий
* нет разделения на группы или пользователи, доступ по одному паролю
* Проблемы фрагментации памяти. Запись и удаление огромных объемов данных может привести к снижению производительности.
* Управление ключами требует значительных усилий. Нет простого способа запустить что-то вроде SELECT COUNT(*) ИЗ REDIS, ГДЕ КЛЮЧ ТИПА '*key*'.
* Управление TTL требует дисциплины на прикладном уровне. Время от времени вы можете оказаться на сервере Redis, переполненном устаревшими данными, потому что некоторые ключи не имеют TTL.
