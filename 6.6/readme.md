# 6.6. Troubleshooting

1.  
```
Используем db.currentOp() для поиска ID и db.killOp(<opid of the query to kill>) завершаем

Для избежания данной проблемы можно добавить параметр maxTimeMS
```

2.  
```
При превышении объёма хранимых значений, которые ещё не истекли, они превышают объём доступной для Redis памяти, операции malloc() блокируются и записать больше данных в БД невозможно, пока часть памяти
не освободится. Решением будет увеличить значение параметра maxmemory в конфиге Redis, еще можно разрешить использование виртуальной памяти. 
Если возможно увеличить память нет, то можно использовать одну из политик, срабатывающих после достижения лимита доступной памяти к примеру:
volatile-lru - удалять ключи с TTL, которые редко используются
allkeys-lru - удалять ключи с TTL и без TTL, которые редко используются
```
3.  
```
Иногда ошибка возникает, когда миллионы строк отправляются как часть одного или нескольких запросов. Если вы знаете, что это происходит, попробуйте увеличить net_read_timeout значение по умолчанию, 
равное 30 секундам, до 60 секунд или дольше, что достаточно для завершения передачи данных. Реже это может произойти, когда клиент пытается установить начальное соединение с сервером. 
В этом случае, если ваше connect_timeout значение установлено всего на несколько секунд, вы можете решить проблему, увеличив его до десяти секунд, а может быть и больше, 
если у вас очень большое расстояние или медленное соединение. Вы можете определить, сталкиваетесь ли вы с этой более редкой причиной, используя SHOW GLOBAL STATUS LIKE 'Aborted_connects'. 

```
4.  
```
oom-killer срабатывает при заканчивании RAM на сервере, дабы не допустить падение всего сервера, для решения можно попробовать:
- увеличить доступную RAM на сервере 
- включить своп файл 
- проанализировать длительные (тяжелые) запросы, возможно можно что то переписать
```
